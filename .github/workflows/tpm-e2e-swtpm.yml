name: TPM E2E (swtpm)

on:
  workflow_dispatch: {}
  push:
    branches:
      - main

jobs:
  tpm-e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Prepare environment
        run: |
          sudo apt-get update -y
          # Install TPM packages; prefer 0t64 ABI suffixed packages present on runner and fall back to older names
          sudo apt-get install -y -qq swtpm swtpm-tools tpm2-tools \
            libtss2-tcti-libtpms0t64 libtss2-tcti-swtpm0t64 libtss2-tcti-libtpms libtss2-tcti-swtpm \
            libtpms0t64 libtpms0 jq python3 openssl
          sudo mkdir -p /usr/local/bin || true
          # Ensure Python deps needed by validator are present
          python3 -m pip install --upgrade pip pyyaml

      - name: Make scripts executable
        run: |
          chmod +x scripts/tpm/*.sh

      - name: Run Beats 1-5 under swtpm
        run: |
          echo "PWD: $(pwd)"
          echo "Listing scripts/tpm:"
          ls -la scripts/tpm || true
          echo "Listing scripts:"
          ls -la scripts || true
          ./scripts/tpm/ci_run_beats_1_to_5.sh
        env:
          OUTDIR: tmp

      - name: Issue TPM-backed SSH cert
        run: |
          chmod +x scripts/tpm/issue_tpm_ssh_cert.sh
          ./scripts/tpm/issue_tpm_ssh_cert.sh
        env:
          OUTDIR: tmp

      - name: Verify SSH cert via challenge signature (simulated SSH login)
        run: |
          set -euo pipefail
          # Find the cert and the pub
          CERT=$(ls -1t tmp/sign_ssh_cert_* -1 2>/dev/null | head -n1 || true)
          PUB=$(ls -1t tmp/sign_ssh_pub_* -1 2>/dev/null | head -n1 || true)
          if [ -z "$CERT" ] || [ -z "$PUB" ]; then echo "No cert/pub found" >&2; exit 1; fi
          echo "Found cert=$CERT pub=$PUB"

          # extract public key PEM from the earlier sign pub PEM created in Beat2
          SIGN_PEM=$(ls -1t tmp/sign_pub_for_ssh_* 2>/dev/null | head -n1 || true)
          if [ -z "$SIGN_PEM" ]; then echo "No sign PEM found" >&2; exit 1; fi

          # Challenge
          CHALLENGE=tmp/challenge.bin
          echo -n "ci-challenge-$(date +%s)" > "$CHALLENGE"

          # sign with TPM persistent signing handle: read sign handle from helper script
          SIGN_HANDLE=$(OUTDIR=tmp python3 scripts/tpm/get_sign_handle.py)
          if [ -z "$SIGN_HANDLE" ]; then echo "No sign handle found" >&2; exit 1; fi
          echo "Signing with handle $SIGN_HANDLE"

          SIG=tmp/challenge.sig
          tpm2_sign -c "$SIGN_HANDLE" -g sha256 -o "$SIG" "$CHALLENGE" || { echo 'tpm2_sign failed' >&2; exit 1; }

          # verify signature with public key PEM
          PEM=$(ls -1t tmp/sign_pub_for_ssh_* | head -n1)
          if [ -z "$PEM" ]; then echo "sign pub pem missing" >&2; exit 1; fi
          # openssl verify
          if openssl dgst -sha256 -verify "$PEM" -signature "$SIG" "$CHALLENGE" >/dev/null 2>&1; then
            echo "Signature verified with TPM-resident key: OK"
          else
            echo "Signature verification failed" >&2; exit 1
          fi

          # check certificate was signed by CA
          if ssh-keygen -L -f "$CERT" | grep -qi 'Signature:'; then
            echo "Certificate appears signed by CA: OK"
          else
            echo "Certificate signature missing or invalid" >&2; ssh-keygen -L -f "$CERT" || true; exit 1
          fi

      - name: Onboarding request
        run: |
          chmod +x scripts/tpm/request_onboarding.sh
          REQ=$(./scripts/tpm/request_onboarding.sh)
          echo "Request created: $REQ"
        env:
          OUTDIR: tmp

      - name: Onboard service (verify & issue token)
        run: |
          python3 scripts/tpm/onboard_service.py "$REQ"
          # output token file path (last onboarding_issue event contains token_file)
          TOKEN_FILE=$(ls -1t tmp/onboard_token_*.txt 2>/dev/null | head -n1 || true)
          if [ -z "$TOKEN_FILE" ]; then echo "No token file created" >&2; exit 1; fi
          TOKEN=$(cat "$TOKEN_FILE")
          echo "TOKEN_FILE=$TOKEN_FILE"; echo "TOKEN_LEN=${#TOKEN}";
        env:
          OUTDIR: tmp

      - name: Start JWT acceptance server
        run: |
          chmod +x scripts/tpm/accept_jwt_server.py
          python3 scripts/tpm/accept_jwt_server.py &
          sleep 1

      - name: Use token to access protected endpoint
        run: |
          TOKEN_FILE=$(ls -1t tmp/onboard_token_*.txt 2>/dev/null | head -n1 || true)
          if [ -z "$TOKEN_FILE" ]; then echo "no token" >&2; exit 1; fi
          TOKEN=$(cat "$TOKEN_FILE")
          for i in 1 2 3; do
            HTTP=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" http://127.0.0.1:8080/validate || true)
            echo "Attempt $i: HTTP=$HTTP"
            if [ "$HTTP" = "200" ]; then echo OK; break; fi
            sleep 1
          done
          if [ "$HTTP" != "200" ]; then echo "Protected endpoint access failed" >&2; exit 1; fi

      - name: "Negative test: corrupt attestation and assert onboarding rejected"
        run: |
          set -euo pipefail
          CORRUPT=$(./scripts/tpm/corrupt_attestation.sh)
          echo "Created corrupt attest: $CORRUPT"
          # Create request and then patch 'attest_log' to point to corrupt file
          REQ=$(./scripts/tpm/request_onboarding.sh)
          REQ_MOD=${REQ/.json/_corrupt.json}
          jq --arg a "$CORRUPT" '.attest_log=$a' "$REQ" > "$REQ_MOD"
          echo "Running onboard service with corrupt attest (expect failure)"
          set +e
          python3 scripts/tpm/onboard_service.py "$REQ_MOD"
          RC=$?
          set -e
          if [ "$RC" -eq 0 ]; then
            echo "Onboarding unexpectedly succeeded with corrupt attestation" >&2
            exit 1
          fi
          echo "Onboarding failed as expected (rc=$RC)"
          # verify NDJSON contains a canonical onboarding_reject entry and validate schema
          chmod +x scripts/tpm/assert_rejections_schema.sh
          ./scripts/tpm/assert_rejections_schema.sh attestation_verify_failed
          echo "Rejection schema validated: OK"

      - name: Upload TPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tpm-e2e-artifacts
          path: tmp/**

      - name: Dump small summary
        run: |
          echo "--- TMP LIST ---"
          ls -R tmp | sed -n '1,200p'

      - name: Upload TPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tpm-e2e-artifacts
          path: tmp/**

      - name: Dump small summary
        run: |
          echo "--- TMP LIST ---"
          ls -R tmp | sed -n '1,200p'
