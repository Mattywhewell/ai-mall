name: TPM E2E (swtpm)

on:
  workflow_dispatch: {}
  push:
    branches:
      - main

jobs:
  tpm-e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Prepare environment
        run: |
          sudo apt-get update -y
          sudo apt-get install -y -qq swtpm swtpm-tools tpm2-tools jq python3 openssl
          sudo mkdir -p /usr/local/bin || true

      - name: Make scripts executable
        run: |
          chmod +x scripts/tpm/*.sh

      - name: Run Beats 1-5 under swtpm
        run: |
          ./scripts/tpm/ci_run_beats_1_to_5.sh
        env:
          OUTDIR: tmp

      - name: Issue TPM-backed SSH cert
        run: |
          chmod +x scripts/tpm/issue_tpm_ssh_cert.sh
          ./scripts/tpm/issue_tpm_ssh_cert.sh
        env:
          OUTDIR: tmp

      - name: Verify SSH cert via challenge signature (simulated SSH login)
        run: |
          set -euo pipefail
          # Find the cert and the pub
          CERT=$(ls -1t tmp/sign_ssh_cert_* -1 2>/dev/null | head -n1 || true)
          PUB=$(ls -1t tmp/sign_ssh_pub_* -1 2>/dev/null | head -n1 || true)
          if [ -z "$CERT" ] || [ -z "$PUB" ]; then echo "No cert/pub found" >&2; exit 1; fi
          echo "Found cert=$CERT pub=$PUB"

          # extract public key PEM from the earlier sign pub PEM created in Beat2
          SIGN_PEM=$(ls -1t tmp/sign_pub_for_ssh_* 2>/dev/null | head -n1 || true)
          if [ -z "$SIGN_PEM" ]; then echo "No sign PEM found" >&2; exit 1; fi

          # Challenge
          CHALLENGE=tmp/challenge.bin
          echo -n "ci-challenge-$(date +%s)" > "$CHALLENGE"

          # sign with TPM persistent signing handle: try to read sign handle from lineage
          SIGN_HANDLE=$(python3 - <<PY
import json,sys,glob
f=sorted(glob.glob('tmp/tpm_beat2_*.ndjson'),reverse=True)
if f:
  for l in open(f[0]):
    try:
      o=json.loads(l)
    except:
      continue
    if o.get('key_type')=='SIGNING':
      print(o.get('handle',''))
      sys.exit(0)
print('')
PY
)
          if [ -z "$SIGN_HANDLE" ]; then echo "No sign handle found" >&2; exit 1; fi
          echo "Signing with handle $SIGN_HANDLE"

          SIG=tmp/challenge.sig
          tpm2_sign -c "$SIGN_HANDLE" -g sha256 -o "$SIG" "$CHALLENGE" || { echo 'tpm2_sign failed' >&2; exit 1; }

          # verify signature with public key PEM
          PEM=$(ls -1t tmp/sign_pub_for_ssh_* | head -n1)
          if [ -z "$PEM" ]; then echo "sign pub pem missing" >&2; exit 1; fi
          # openssl verify
          if openssl dgst -sha256 -verify "$PEM" -signature "$SIG" "$CHALLENGE" >/dev/null 2>&1; then
            echo "Signature verified with TPM-resident key: OK"
          else
            echo "Signature verification failed" >&2; exit 1
          fi

          # check certificate was signed by CA
          if ssh-keygen -L -f "$CERT" | grep -qi 'Signature:'; then
            echo "Certificate appears signed by CA: OK"
          else
            echo "Certificate signature missing or invalid" >&2; ssh-keygen -L -f "$CERT" || true; exit 1
          fi

      - name: Onboarding request
        run: |
          chmod +x scripts/tpm/request_onboarding.sh
          REQ=$(./scripts/tpm/request_onboarding.sh)
          echo "Request created: $REQ"
        env:
          OUTDIR: tmp

      - name: Onboard service (verify & issue token)
        run: |
          python3 scripts/tpm/onboard_service.py "$REQ"
          # output token file path (last onboarding_issue event contains token_file)
          TOKEN_FILE=$(ls -1t tmp/onboard_token_*.txt 2>/dev/null | head -n1 || true)
          if [ -z "$TOKEN_FILE" ]; then echo "No token file created" >&2; exit 1; fi
          TOKEN=$(cat "$TOKEN_FILE")
          echo "TOKEN_FILE=$TOKEN_FILE"; echo "TOKEN_LEN=${#TOKEN}";
        env:
          OUTDIR: tmp

      - name: Start JWT acceptance server
        run: |
          chmod +x scripts/tpm/accept_jwt_server.py
          python3 scripts/tpm/accept_jwt_server.py &
          sleep 1

      - name: Use token to access protected endpoint
        run: |
          TOKEN_FILE=$(ls -1t tmp/onboard_token_*.txt 2>/dev/null | head -n1 || true)
          if [ -z "$TOKEN_FILE" ]; then echo "no token" >&2; exit 1; fi
          TOKEN=$(cat "$TOKEN_FILE")
          for i in 1 2 3; do
            HTTP=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" http://127.0.0.1:8080/validate || true)
            echo "Attempt $i: HTTP=$HTTP"
            if [ "$HTTP" = "200" ]; then echo OK; break; fi
            sleep 1
          done
          if [ "$HTTP" != "200" ]; then echo "Protected endpoint access failed" >&2; exit 1; fi

      - name: Upload TPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tpm-e2e-artifacts
          path: tmp/**

      - name: Dump small summary
        run: |
          echo "--- TMP LIST ---"
          ls -R tmp | sed -n '1,200p'

      - name: Upload TPM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tpm-e2e-artifacts
          path: tmp/**

      - name: Dump small summary
        run: |
          echo "--- TMP LIST ---"
          ls -R tmp | sed -n '1,200p'
