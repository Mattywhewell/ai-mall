#!/usr/bin/env bash
# AuthorizedPrincipalsCommand-style revocation check
# Usage: authorized_principals_command.sh <cert-file> [revocation-list]
set -euo pipefail
source "$(dirname "$0")/lib/log.sh"

CERT_FILE=${1:-}
REVOCATION_LIST=${2:-/etc/ssh/revoked_cert_serials}
TEST_ROOT=${TEST_ROOT:-}

if [ -n "$TEST_ROOT" ]; then
  REVOCATION_LIST="$TEST_ROOT/etc/ssh/revoked_cert_serials"
fi

if [ -z "$CERT_FILE" ]; then
  echo "Usage: $0 <cert-file> [revocation-list]" >&2; exit 2
fi

if [ ! -f "$CERT_FILE" ]; then
  migration_log "step=authorized_principals" "action=failed" "reason=cert_not_found" "cert=$CERT_FILE"
  exit 3
fi

# Extract serial
SERIAL=$(ssh-keygen -Lf "$CERT_FILE" | awk '/Serial/ {print $2; exit}') || true
if [ -z "$SERIAL" ]; then
  migration_log "step=authorized_principals" "action=failed" "reason=serial_parse_failed" "cert=$CERT_FILE"
  exit 4
fi

# Check revocation
if [ -f "$REVOCATION_LIST" ] && grep -q "^${SERIAL}$" "$REVOCATION_LIST"; then
  migration_log "step=authorized_principals" "action=deny" "serial=$SERIAL" "cert=$CERT_FILE"
  # For AuthorizedPrincipalsCommand, failing to output principals denies access.
  exit 1
fi

# Extract principals robustly (handle case/format variations)
# Try 'Principals:' first (typical ssh-keygen -Lf output), then fallback to 'Valid principals'
# Also handle the single-line summary that contains 'for <principals> valid' (generated by ssh-keygen when signing)
SSH_LF_OUT=$(ssh-keygen -Lf "$CERT_FILE" 2>/dev/null || true)
PR_LINE=$(echo "$SSH_LF_OUT" | grep -i -E '^\s*Principals:|^\s*Valid principals' -m1 || true)
PRINCIPALS_LINE=""
if [ -n "$PR_LINE" ]; then
  # If principals are on the same line (e.g., 'Principals: adele,admin'), extract them
  PRINCIPALS_LINE=$(echo "$PR_LINE" | sed -E 's/^[^:]*:[[:space:]]*//')
  if [ -z "$PRINCIPALS_LINE" ]; then
    # Principals may be listed on subsequent indented lines. Collect them.
    PRINCIPALS_LINE=$(echo "$SSH_LF_OUT" | awk '/^[[:space:]]*Principals:/{p=1; next} p && /^[[:space:]]+[^[:space:]]/ && $0 !~ /:/{gsub(/^[[:space:]]+/,"",$0); print $0; next} p{exit}' | paste -sd ',' - || true)
  fi
else
  # Fallback: extract between ' for ' and ' valid' in the one-line summary
  PRINCIPALS_LINE=$(echo "$SSH_LF_OUT" | sed -nE 's/.* for ([^ ]+(, *[^ ]+)*) valid.*/\1/p' || true)
  if [ -z "$PRINCIPALS_LINE" ]; then
    # Handle case where ssh-keygen breaks the 'for ... valid' across lines (e.g., 'for adele,admin\n valid ...')
    # Normalize to a single line and try again
    SSH_LF_ONE_LINE=$(echo "$SSH_LF_OUT" | tr '\n' ' ')
    PRINCIPALS_LINE=$(echo "$SSH_LF_ONE_LINE" | sed -nE 's/.* for ([^ ]+(, *[^ ]+)*) valid.*/\1/p' || true)
    if [ -z "$PRINCIPALS_LINE" ]; then
      # Try awk with regex against the collapsed one-line string (uses gawk match capture array)
      PRINCIPALS_LINE=$(echo "$SSH_LF_ONE_LINE" | awk 'match($0,/ for ([^ ]+(, *[^ ]+)*) valid/,a){print a[1]}' || true)
    fi
    if [ -z "$PRINCIPALS_LINE" ]; then
      # Last resort: token-wise awk extraction (handles more exotic spacing)
      PRINCIPALS_LINE=$(echo "$SSH_LF_OUT" | awk 'BEGIN{found=0} {for(i=1;i<=NF;i++){if(found){ if($i=="valid"){found=0; exit} printf "%s ",$i} if($i=="for"){found=1}}} END{if(found)print ""}' | sed 's/ $//' || true)
    fi
  fi
fi

if [ -z "$PRINCIPALS_LINE" ]; then
  # Debug: capture ssh-keygen -Lf output in log for diagnosis
  migration_log "step=authorized_principals" "action=failed" "reason=no_principals_found" "serial=$SERIAL" "ssh_lf_out=$(echo "$SSH_LF_OUT" | tr '\n' ' ' | sed 's/"/\\"/g')"
  exit 1
fi

# Debug: show the raw principals line for troubleshooting
echo "DEBUG: PRINCIPALS_LINE=<$PRINCIPALS_LINE>"
# Debug raw (show hidden whitespace/control chars)
printf '%s' "$PRINCIPALS_LINE" | sed -n 'l'
# Debug: show split lines and count
echo "DEBUG: SPLIT LINES:"; printf '%s' "$PRINCIPALS_LINE" | tr ',' '\n' | sed -n '1,200p'
echo "DEBUG: SPLIT COUNT:"; printf '%s' "$PRINCIPALS_LINE" | tr ',' '\n' | wc -l

# Split principals on comma and print each on its own line
# But first, verify TPM-bound principals via attestation verifier.
# Any "tpm:<device>" principal must have a matching enrollment (pubkey) and a valid attestation.
IFS=$'\n'
VALIDATED_PRINCIPALS=()
while IFS= read -r p; do
  p_trim=$(echo "$p" | sed 's/^\s*//;s/\s*$//')
  echo "DEBUG: principal parsed=<$p_trim>" >&2
  if [ -n "$(echo "$p_trim" | grep -E '^tpm:')" ]; then
    # Device principal: tpm:device-id
    DEVICE=${p_trim#tpm:}
    ATTEST_FILE="$TEST_ROOT/etc/ssh/keys/hardware/attestations/${DEVICE}-attestation.json"
    PUBKEY_FILE="$TEST_ROOT/etc/ssh/keys/hardware/${DEVICE}.pub"
    if [ ! -f "$ATTEST_FILE" ] || [ ! -f "$PUBKEY_FILE" ]; then
      migration_log "step=authorized_principals" "action=deny" "serial=$SERIAL" "reason=attestation_missing_or_pub_missing" "device=$DEVICE"
      exit 1
    fi
    # Call verifier
    if ! "$(dirname "$0")/scene-5/verify_attestation.sh" "$DEVICE" "$ATTEST_FILE" "$PUBKEY_FILE"; then
      migration_log "step=authorized_principals" "action=deny" "serial=$SERIAL" "reason=attestation_invalid" "device=$DEVICE"
      exit 1
    fi
    VALIDATED_PRINCIPALS+=("$p_trim")
  else
    VALIDATED_PRINCIPALS+=("$p_trim")
  fi
done < <(printf '%s' "$PRINCIPALS_LINE" | tr ',' '\n')

# If all verifications passed, print principals
(printf '%s\n' "${VALIDATED_PRINCIPALS[@]}") | tee /dev/stderr >/dev/stdout
migration_log "step=authorized_principals" "action=done" "serial=$SERIAL" "principals=$PRINCIPALS_LINE"
exit 0
