#!/usr/bin/env node
// Purpose: Read `supabase-introspect.log` and emit findings + a patch skeleton for DB patching.
// Usage: node scripts/parse-introspection.js <path-to-introspect-dir>
// Example: node scripts/parse-introspection.js ./introspect-logs-20260119T110000Z

const fs = require('fs');
const path = require('path');
const child = require('child_process');

function unzipIfNeeded(inputPath, tmpDir) {
  if (!inputPath.endsWith('.zip')) return inputPath;
  if (!fs.existsSync(inputPath)) throw new Error('Zip file not found: ' + inputPath);
  if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir, { recursive: true });
  console.log('Unzipping', inputPath, 'to', tmpDir);
  try {
    if (process.platform === 'win32') {
      child.execSync(`powershell -Command "Expand-Archive -LiteralPath '${inputPath}' -DestinationPath '${tmpDir}' -Force"`);
    } else {
      child.execSync(`unzip -o '${inputPath}' -d '${tmpDir}'`);
    }
  } catch (err) {
    console.error('Failed to unzip automatically, please extract manually and pass the folder path. Error:', err.message);
    process.exit(1);
  }
  return tmpDir;
}

function loadLog(dir) {
  const logPath = path.join(dir, 'supabase-introspect.log');
  if (!fs.existsSync(logPath)) throw new Error('Could not find supabase-introspect.log in ' + dir);
  return fs.readFileSync(logPath, 'utf8');
}

function extractLabel(log, label) {
  // Find the line with 'LABEL RESULT:' or 'LABEL ERROR' capturing the rest of line
  const re = new RegExp('---\\s*' + label + '(?:[^\n]*)\\n([\s\S]*?)(?=\\n---|$)', 'i');
  const m = log.match(re);
  if (!m) return { raw: null, rows: null, error: 'not found' };
  const block = m[1].trim();
  // Try to find 'RESULT:' or 'ERROR:' lines
  const lines = block.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  let resultLine = null;
  for (const l of lines) {
    if (/RESULT:/i.test(l) || /ERROR:/i.test(l) || /ERROR \(direct PG\)/i.test(l)) { resultLine = l; break; }
  }
  if (!resultLine) return { raw: block, rows: null, error: 'no RESULT line' };
  const idx = resultLine.indexOf('RESULT:');
  if (idx !== -1) {
    const after = resultLine.slice(idx + 'RESULT:'.length).trim();
    try {
      const parsed = JSON.parse(after);
      return { raw: block, rows: parsed, error: null };
    } catch (e) {
      // Maybe the result spans multiple lines or is not valid JSON (truncated)
      // Try to join subsequent lines that look like JSON
      const maybe = lines.slice(lines.indexOf(resultLine)).join('\n').replace(/^RESULT:\s*/i, '').trim();
      try { return { raw: block, rows: JSON.parse(maybe), error: null }; } catch (e2) { return { raw: block, rows: maybe, error: 'non-json' }; }
    }
  } else if (/ERROR/i.test(resultLine)) {
    return { raw: block, rows: null, error: resultLine };
  }
  return { raw: block, rows: null, error: 'unhandled' };
}

function summarize(findings) {
  const lines = [];
  lines.push('# Introspection Findings Summary');
  for (const k of Object.keys(findings)) {
    const v = findings[k];
    lines.push(`\n## ${k}`);
    if (v.error) { lines.push(`> Error: ${v.error}`); continue; }
    if (!v.rows) { lines.push('No rows found.'); continue; }
    if (Array.isArray(v.rows) && v.rows.length === 0) { lines.push('No rows found.'); continue; }
    try {
      if (Array.isArray(v.rows)) {
        for (const r of v.rows) {
          lines.push('- ' + Object.entries(r).map(([a,b]) => `${a}: ${JSON.stringify(b)}`).join(' | '));
        }
      } else {
        lines.push('- ' + JSON.stringify(v.rows).slice(0, 1000));
      }
    } catch (e) { lines.push('Could not render rows.'); }
  }
  return lines.join('\n');
}

function generatePatchSkeleton(findings) {
  const parts = [];
  parts.push('-- IDMPOTENT SQL PATCH SKELETONS (AUTOGENERATED)\n-- Review and adjust carefully before applying. Run in staging first.\n');

  // Ensure user_role type exists
  parts.push("-- Ensure enum type exists (idempotent)\nDO $$\nBEGIN\n  IF NOT EXISTS (SELECT 1 FROM pg_type t JOIN pg_namespace n ON t.typnamespace = n.oid WHERE t.typname = 'user_role' AND n.nspname = 'public') THEN\n    CREATE TYPE public.user_role AS ENUM ('admin','supplier','customer','ai_agent');\n  END IF;\nEND $$;\n");

  // Functions
  const fn = findings['FUNCTIONS'];
  if (fn && !fn.error && Array.isArray(fn.rows) && fn.rows.length) {
    parts.push('-- Functions referencing user_role: review and patch individually\n');
    for (const f of fn.rows) {
      const name = f.proname || f.name || (f.def && f.def.split('\n')[0]);
      parts.push(`-- Function: ${name}\n-- def preview: ${JSON.stringify(f.def || f)}\n-- Example: replace function in idempotent manner\nDO $$\nBEGIN\n  -- Example: CREATE OR REPLACE FUNCTION ${name} (...) RETURNS ... AS $$ ... $$ LANGUAGE plpgsql;\n  -- Replace above with reviewed function body.\nEXCEPTION WHEN OTHERS THEN RAISE NOTICE('Function ${name} patch encountered: %', SQLERRM); END $$;\n`);
    }
  }

  // Policies
  const pol = findings['POLICIES'];
  if (pol && !pol.error && Array.isArray(pol.rows) && pol.rows.length) {
    parts.push('-- Policies referencing user_role: ensure policies are correct and idempotent\n');
    for (const p of pol.rows) {
      parts.push(`-- Policy ${p.polname} on ${p.table} \n-- qual: ${p.qual} \n-- withcheck: ${p.withcheck} \n-- Example idempotent enable: \nDO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname='${p.polname}' AND polrelid = '${p.table}'::regclass) THEN CREATE POLICY ${p.polname} ON ${p.table} FOR ALL USING (${p.qual || 'TRUE'}); END IF; END $$;\n`);
    }
  }

  // Defaults and constraints
  const defs = findings['DEFAULTS'];
  if (defs && !defs.error && Array.isArray(defs.rows) && defs.rows.length) {
    parts.push('-- Column defaults referencing user_role: review and patch\n');
    for (const d of defs.rows) {
      parts.push(`-- ${d.table}.${d.column} default: ${d.default_expr} \n-- Example to set default idempotently:\nALTER TABLE ${d.table} ALTER COLUMN ${d.column} SET DEFAULT ${d.default_expr};\n`);
    }
  }

  const cons = findings['CONSTRAINTS'];
  if (cons && !cons.error && Array.isArray(cons.rows) && cons.rows.length) {
    parts.push('-- Constraints referencing user_role: review and patch\n');
    for (const c of cons.rows) {
      parts.push(`-- ${c.table} constraint ${c.conname}: ${c.def} \n-- Example (manual): DROP CONSTRAINT IF EXISTS ${c.conname} ON ${c.table};\n`);
    }
  }

  parts.push('-- After applying patches, re-run introspection and the admin createUser diagnostic.');
  return parts.join('\n');
}

(async function main() {
  const input = process.argv[2] || './';
  const outdir = process.argv[3] || process.cwd();
  let dir = input;
  if (input.endsWith('.zip')) {
    const tmp = path.join(process.cwd(), 'introspect-unzip-temp');
    dir = unzipIfNeeded(input, tmp);
  }
  if (!fs.existsSync(dir) || !fs.lstatSync(dir).isDirectory()) {
    console.error('Provided input is not a directory:', dir);
    process.exit(1);
  }
  let log;
  try { log = loadLog(dir); } catch (err) { console.error(err.message); process.exit(1); }

  const labels = ['FUNCTIONS','TRIGGERS','COLUMNS','AUTH_USERS_TRIGGERS','DEPENDENCIES','ATTRIBUTES','PROC_TYPES','VIEWS','POLICIES','DEFAULTS','CONSTRAINTS'];
  const findings = {};
  for (const l of labels) {
    findings[l] = extractLabel(log, l);
  }

  // Write findings.json and findings.md
  const outJson = path.join(outdir, 'introspection-findings.json');
  fs.writeFileSync(outJson, JSON.stringify(findings, null, 2));
  const md = summarize(findings);
  const outMd = path.join(outdir, 'introspection-findings.md');
  fs.writeFileSync(outMd, md);

  // Generate patch skeleton
  const patches = generatePatchSkeleton(findings);
  const patchPath = path.join(outdir, 'introspection-patches.sql');
  fs.writeFileSync(patchPath, patches);

  console.log('\n✅ Findings written to:', outJson);
  console.log('✅ Summary written to:', outMd);
  console.log('✅ Patch skeleton written to:', patchPath);
})();
